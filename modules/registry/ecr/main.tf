#------------------------------------------------------------------------------
# ECR Repository Module
#
# Creates an Amazon Elastic Container Registry (ECR) repository for:
# - Custom container images for any ROSA cluster (Classic or HCP)
# - Operator mirroring for zero-egress HCP clusters
#
# Features:
# - Optional KMS encryption (defaults to AES-256)
# - Image scanning on push
# - Lifecycle policy for image retention
#
# Usage:
# 1. Enable create_ecr = true in your environment tfvars
# 2. Attach ECR policy to worker IAM role (done automatically when create_ecr = true)
# 3. Push images to the repository URL from outputs
#
# For zero-egress operator mirroring, see docs/ZERO-EGRESS.md
#------------------------------------------------------------------------------

locals {
  repository_name = var.repository_name != "" ? var.repository_name : "${var.cluster_name}-registry"
}

#------------------------------------------------------------------------------
# ECR Repository
#
# Two resources to handle prevent_destroy (lifecycle block requires literal bool).
# Only one will be created based on var.prevent_destroy.
#------------------------------------------------------------------------------

# Standard repository - destroyed with cluster
resource "aws_ecr_repository" "this" {
  count = var.prevent_destroy ? 0 : 1

  name                 = local.repository_name
  image_tag_mutability = var.image_tag_mutability
  force_delete         = var.force_delete

  image_scanning_configuration {
    scan_on_push = var.scan_on_push
  }

  encryption_configuration {
    encryption_type = var.kms_key_arn != null ? "KMS" : "AES256"
    kms_key         = var.kms_key_arn
  }

  tags = merge(
    var.tags,
    {
      Name = local.repository_name
    }
  )
}

# Protected repository - survives cluster destruction
resource "aws_ecr_repository" "protected" {
  count = var.prevent_destroy ? 1 : 0

  name                 = local.repository_name
  image_tag_mutability = var.image_tag_mutability
  force_delete         = false # Never force delete protected repos

  image_scanning_configuration {
    scan_on_push = var.scan_on_push
  }

  encryption_configuration {
    encryption_type = var.kms_key_arn != null ? "KMS" : "AES256"
    kms_key         = var.kms_key_arn
  }

  tags = merge(
    var.tags,
    {
      Name        = local.repository_name
      Lifecycle   = "external"
      Description = "Protected from cluster destroy - set prevent_destroy=false to remove"
    }
  )

  lifecycle {
    prevent_destroy = true
  }
}

# Local to reference whichever repository was created
locals {
  ecr_repository = var.prevent_destroy ? aws_ecr_repository.protected[0] : aws_ecr_repository.this[0]
}

#------------------------------------------------------------------------------
# Lifecycle Policy
# Manages image retention to control storage costs
#------------------------------------------------------------------------------

resource "aws_ecr_lifecycle_policy" "this" {
  count = var.lifecycle_policy_enabled ? 1 : 0

  repository = local.ecr_repository.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Remove untagged images after ${var.lifecycle_untagged_days} days"
        selection = {
          tagStatus   = "untagged"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = var.lifecycle_untagged_days
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 2
        description  = "Keep only last ${var.lifecycle_keep_count} tagged images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["v", "latest", "release"]
          countType     = "imageCountMoreThan"
          countNumber   = var.lifecycle_keep_count
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}

#------------------------------------------------------------------------------
# Data Sources
#------------------------------------------------------------------------------

data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

#------------------------------------------------------------------------------
# IDMS (ImageDigestMirrorSet) Configuration
# Generated when ECR is created for zero-egress operator mirroring
#------------------------------------------------------------------------------

locals {
  # ECR registry URL without repository name
  registry_url = "${data.aws_caller_identity.current.account_id}.dkr.ecr.${data.aws_region.current.id}.amazonaws.com"

  # IDMS YAML template for zero-egress clusters
  idms_yaml_template = <<-YAML
---
# ImageDigestMirrorSet for ROSA Zero-Egress Clusters
# Generated by Terraform ECR module
#
# Apply this to your cluster BEFORE enabling GitOps or installing operators:
#   oc apply -f idms-config.yaml
#
# This redirects image pulls from public registries to your private ECR.
apiVersion: config.openshift.io/v1
kind: ImageDigestMirrorSet
metadata:
  name: rosa-operator-mirror
spec:
  imageDigestMirrors:
    # Red Hat Operators
    - source: registry.redhat.io/redhat
      mirrors:
        - ${local.registry_url}/redhat
    # OpenShift Release Images
    - source: quay.io/openshift-release-dev
      mirrors:
        - ${local.registry_url}/openshift-release-dev
    # OperatorHub catalog
    - source: registry.redhat.io/redhat/redhat-operator-index
      mirrors:
        - ${local.registry_url}/redhat/redhat-operator-index
YAML

  # Only set content when generate_idms is true
  idms_content = var.generate_idms ? local.idms_yaml_template : ""
}

resource "local_file" "idms_config" {
  count = var.generate_idms ? 1 : 0

  content  = local.idms_content
  filename = "${path.root}/outputs/idms-config.yaml"

  # Ensure outputs directory exists
  provisioner "local-exec" {
    command = "mkdir -p ${path.root}/outputs"
    when    = create
  }
}

#------------------------------------------------------------------------------
# VPC Endpoints for ECR
#
# ECR requires two interface endpoints for private access:
# - ecr.api: ECR API calls (CreateRepository, ListImages, etc.)
# - ecr.dkr: Docker registry operations (push/pull images)
#
# Note: S3 gateway endpoint is created in the VPC module since ECR stores
# image layers in S3.
#
# Benefits of VPC endpoints:
# 1. Cost savings - No NAT Gateway data processing charges
# 2. Security - Traffic never leaves AWS private network
# 3. Zero-egress support - Required for air-gapped/private clusters
#------------------------------------------------------------------------------

locals {
  # Use the input variable directly for count expressions (known at plan time)
  # The actual VPC values are validated at apply time
  create_endpoints = var.create_vpc_endpoints

  # Use provided security groups or create one
  # Use input variable for count to avoid "value depends on resource attributes" error
  use_default_sg = var.create_vpc_endpoints && length(var.endpoint_security_group_ids) == 0
}

# Default security group for ECR endpoints
resource "aws_security_group" "ecr_endpoints" {
  count = local.use_default_sg ? 1 : 0

  name        = "${var.cluster_name}-ecr-endpoints"
  description = "Security group for ECR VPC endpoints"
  vpc_id      = var.vpc_id

  # Allow HTTPS from within VPC (ECR uses HTTPS on port 443)
  ingress {
    description = "HTTPS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = var.vpc_cidr != null ? [var.vpc_cidr] : []
  }

  # Allow all outbound (endpoints need to respond)
  egress {
    description = "All outbound"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.cluster_name}-ecr-endpoints"
    }
  )
}

locals {
  endpoint_security_group_ids = local.use_default_sg ? [aws_security_group.ecr_endpoints[0].id] : var.endpoint_security_group_ids
}

# ECR API endpoint - for ECR API calls
resource "aws_vpc_endpoint" "ecr_api" {
  count = local.create_endpoints ? 1 : 0

  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${data.aws_region.current.id}.ecr.api"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.private_subnet_ids
  security_group_ids  = local.endpoint_security_group_ids
  private_dns_enabled = true

  tags = merge(
    var.tags,
    {
      Name = "${var.cluster_name}-ecr-api"
    }
  )
}

# ECR DKR endpoint - for Docker registry operations (push/pull)
resource "aws_vpc_endpoint" "ecr_dkr" {
  count = local.create_endpoints ? 1 : 0

  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${data.aws_region.current.id}.ecr.dkr"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.private_subnet_ids
  security_group_ids  = local.endpoint_security_group_ids
  private_dns_enabled = true

  tags = merge(
    var.tags,
    {
      Name = "${var.cluster_name}-ecr-dkr"
    }
  )
}
